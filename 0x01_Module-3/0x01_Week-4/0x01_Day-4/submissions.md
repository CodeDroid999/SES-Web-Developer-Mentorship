
### **Submission Guidelines:**

- **Code Submission**: Submit a GitHub repository link containing your Next.js project with the implemented optimizations.
- **Live URL**: Provide a link to the deployed SSR page (e.g., Vercel or Netlify).
- **Screenshots**: Include screenshots showing before and after performance results, such as the Lighthouse report.
- **Description**: In your submission, explain how you implemented caching, optimized data fetching, and improved performance for SSR pages. Include any challenges you faced during the process.

---

### **Resources:**

- [Next.js Caching with Cache-Control](https://nextjs.org/docs/advanced-features/cache)
- [Server-Side Caching with Redis](https://nextjs.org/docs/advanced-features/using-redis-cache)
- [SWR: React Hooks for Data Fetching](https://swr.vercel.app/)
- [Lighthouse Performance Metrics](https://developers.google.com/web/tools/lighthouse)
- [Web Vitals](https://web.dev/vitals/)

---

### **Evaluation Criteria:**
1. **Correct Use of Caching Strategies**: Proper implementation of Cache-Control headers and server-side caching.
2. **Optimized Data Fetching**: Effective use of **SWR** or **React Query** to manage and cache API data.
3. **Performance Optimization**: Successful implementation of performance optimization techniques, such as code-splitting and lazy loading.
4. **Deployment**: Correctly deploying the optimized SSR application and ensuring the caching and performance optimizations are functioning in the live environment.
5. **Documentation**: Clear explanation of your approach, the optimizations made, and performance results.

---

Today’s task will help you improve your SSR app by making it faster and more scalable. By leveraging caching techniques and optimizing data fetching, you’ll ensure that your SSR application performs well under various traffic conditions. This is an essential skill for building production-level SSR apps that can handle real-time, dynamic content. 

Good luck!
